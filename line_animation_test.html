<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="./css/main.css">
</head>

<body>

	<script type="module">

		import * as THREE from './build/three.module.js';

		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		import { RenderPass } from './jsm/postprocessing/RenderPass.js';
		import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
		import { BloomPass } from './jsm/postprocessing/BloomPass.js';
		import { FilmPass } from './jsm/postprocessing/FilmPass.js';
		import { FocusShader } from './jsm/shaders/FocusShader.js';
		import { OBJLoader } from './jsm/loaders/OBJLoader.js';

		var SCREEN_WIDTH = window.innerWidth,
			SCREEN_HEIGHT = window.innerHeight,
			r = 450,
			mouseY = 0,
			windowHalfY = window.innerHeight / 2,
			camera, scene, renderer;
		var person, personPoints = [];
		var composer, effectFocus;
		var clock = new THREE.Clock();

		init();
		animate();

		function init() {

			camera = new THREE.PerspectiveCamera(80, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 3000);
			camera.position.z = 1000;

			scene = new THREE.Scene();

			var i, line, lineMaterial, p,

				parameters = [[0.5, 0xffffff, 1], [0.75, 0xffffff, 0.75], [1, 0xffffff, 0.5], [1.25, 0xffffff, 0.8],
				[3.0, 0xaaaaaa, 0.75], [3.5, 0xffffff, 0.5], [4.5, 0xffffff, 0.25], [5.5, 0xffffff, 0.125]];

			var lineGeometry = createLineParticle();

			for (i = 0; i < parameters.length; ++i) {
				p = parameters[i];
				lineMaterial = new THREE.LineBasicMaterial({ color: p[1], opacity: p[2] });
				line = new THREE.LineSegments(lineGeometry, lineMaterial);
				line.scale.x = line.scale.y = line.scale.z = p[0];
				line.userData.originalScale = p[0];
				line.rotation.y = Math.random() * Math.PI;
				line.updateMatrix();
				scene.add(line);
			}

			var loader = new OBJLoader();

			loader.load('models/male02.obj', function (object) {
				var positions = combineBuffer(object, 'position');
				createPerson(positions, scene, 0.7, 0, -70, 0, 0xffffff);
			});

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			renderer.autoClear = false;
			document.body.appendChild(renderer.domElement);

			// postprocessing
			var renderModel = new RenderPass(scene, camera);
			var effectBloom = new BloomPass(0.75);
			var effectFilm = new FilmPass(0.5, 0.5, 1448, false);

			effectFocus = new ShaderPass(FocusShader);

			effectFocus.uniforms["screenWidth"].value = window.innerWidth * window.devicePixelRatio;
			effectFocus.uniforms["screenHeight"].value = window.innerHeight * window.devicePixelRatio;

			composer = new EffectComposer(renderer);

			composer.addPass(renderModel);
			composer.addPass(effectBloom);
			composer.addPass(effectFilm);
			composer.addPass(effectFocus);

			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('touchstart', onDocumentTouchStart, false);
			document.addEventListener('touchmove', onDocumentTouchMove, false);

			window.addEventListener('resize', onWindowResize, false);
		}

		function createLineParticle() {
			var geometry = new THREE.BufferGeometry();
			var vertices = [];
			var vertex = new THREE.Vector3();

			for (var i = 0; i < 1500; i++) {
				vertex.x = Math.random() * 2 - 1;
				vertex.y = Math.random() * 2 - 1;
				vertex.z = Math.random() * 2 - 1;
				vertex.normalize();
				vertex.multiplyScalar(r);

				vertices.push(vertex.x, vertex.y, vertex.z);
				vertex.multiplyScalar(Math.random() * 0.09 + 1);
				vertices.push(vertex.x, vertex.y, vertex.z);
			}
			geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
			return geometry;
		}

		function combineBuffer(model, bufferName) {

			let count = 0;

			model.traverse(function (child) {
				if (child.isMesh) {
					var buffer = child.geometry.attributes[bufferName];
					count += buffer.array.length;
				}
			});

			var combined = new Float32Array(count);
			let offset = 0;
			model.traverse(function (child) {
				if (child.isMesh) {
					var buffer = child.geometry.attributes[bufferName];
					combined.set(buffer.array, offset);
					offset += buffer.array.length;
				}
			});

			return new THREE.BufferAttribute(combined, 3);

		}

		function createPerson(positions, scene, scale, x, y, z, color) {

			var geometry = new THREE.BufferGeometry();
			geometry.setAttribute('position', positions.clone());
			geometry.setAttribute('initialPosition', positions.clone());

			geometry.attributes.position.setUsage(THREE.DynamicDrawUsage);

			person = new THREE.Points(geometry,
				new THREE.PointsMaterial({
					size: 3,
					color: color,
					blending: THREE.AdditiveBlending,
					transparent: true,
					depthTest: false,
					sizeAttenuation: true,
					opacity: 0.2
				}));
			person.scale.x = person.scale.y = person.scale.z = scale;

			person.position.x = x;
			person.position.y = y;
			person.position.z = z;

			scene.add(person);

			personPoints.push({
				mesh: person, verticesDown: 0, verticesUp: 0, direction: 0, speed: 15, delay: Math.floor(200 + 200 * Math.random()),
				start: Math.floor(100 + 200 * Math.random()),
			});
		}

		function onWindowResize() {

			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			composer.setSize(window.innerWidth, window.innerHeight);

			effectFocus.uniforms["screenWidth"].value = window.innerWidth * window.devicePixelRatio;
			effectFocus.uniforms["screenHeight"].value = window.innerHeight * window.devicePixelRatio;
		}

		function onDocumentMouseMove(event) {
			mouseY = event.clientY - windowHalfY;
		}

		function onDocumentTouchStart(event) {
			if (event.touches.length > 1) {
				event.preventDefault();
				mouseY = event.touches[0].pageY - windowHalfY;
			}
		}

		function onDocumentTouchMove(event) {
			if (event.touches.length == 1) {
				event.preventDefault();
				mouseY = event.touches[0].pageY - windowHalfY;
			}
		}

		function animate() {
			requestAnimationFrame(animate);
			render();
		}

		function render() {
			camera.position.y += (- mouseY + 200 - camera.position.y) * .05;
			camera.lookAt(scene.position);

			renderer.render(scene, camera);

			var time = Date.now() * 0.0001;
			var delta = 10 * clock.getDelta();
			delta = delta < 2 ? delta : 2;

			for (var i = 0; i < scene.children.length; i++) {
				var object = scene.children[i];
				if (object.isLine) {
					object.rotation.y = time * (i < 4 ? (i + 1) : - (i + 1));
					if (i < 5) {
						var scale = object.userData.originalScale * (i / 5 + 1) * (1 + 0.5 * Math.sin(7 * time));
						object.scale.x = object.scale.y = object.scale.z = scale;
					}
				}
			}

			// person.rotation.y += -0.1 * delta * (0.5 + Math.random());
			for (var j = 0; j < personPoints.length; j++) {

				var data = personPoints[j];
				var positions = data.mesh.geometry.attributes.position;
				var initialPositions = data.mesh.geometry.attributes.initialPosition;

				var count = positions.count;

				if (data.start > 0) {
					data.start -= 1;
				} else {
					if (data.direction === 0) {
						data.direction = - 1;
					}
				}

				for (var i = 0; i < count; i++) {
					var px = positions.getX(i);
					var py = positions.getY(i);
					var pz = positions.getZ(i);

					// zoom out
					if (data.direction < 0) {
						if (py > -15) {
							positions.setXYZ(
								i,
								px + 1.5 * (0.50 - Math.random()) * data.speed * delta,
								py + 1.5 * (0.50 - Math.random()) * data.speed * delta,
								pz + 1.5 * (0.50 - Math.random()) * data.speed * delta
							);
						} else {
							data.verticesDown += 1;
						}
					}

					// zoom in
					if (data.direction > 0) {
						var ix = initialPositions.getX(i);
						var iy = initialPositions.getY(i);
						var iz = initialPositions.getZ(i);

						var dx = Math.abs(px - ix);
						var dy = Math.abs(py - iy);
						var dz = Math.abs(pz - iz);

						var d = dx + dy + dx;

						if (d > 1) {
							positions.setXYZ(
								i,
								px - (px - ix) / dx * data.speed * delta * (0.85 - Math.random()),
								py - (py - iy) / dy * data.speed * delta * (0.85 - Math.random()),
								pz - (pz - iz) / dz * data.speed * delta * (0.85 - Math.random())
							);
						} else {
							data.verticesUp += 1;
						}
					}
				}
				// all vertices down
				if (data.verticesDown >= count) {
					if (data.delay <= 0) {
						data.direction = 1;
						data.speed = 5;
						data.verticesDown = 0;
						data.delay = 320;

					} else {
						data.delay -= 1;
					}
				}

				// all vertices up
				if (data.verticesUp >= count) {
					if (data.delay <= 0) {
						data.direction = - 1;
						data.speed = 15;
						data.verticesUp = 0;
						data.delay = 120;
					} else {
						data.delay -= 1;
					}
				}
				positions.needsUpdate = true;
			}

			composer.render(0.01);
		}
	</script>
</body>

</html>